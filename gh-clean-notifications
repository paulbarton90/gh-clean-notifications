#!/usr/bin/env bash
set -e


NOTIFICATION_QUERY="query NotificationsQuery(\$first: Int!, \$endCursor: String, \$miscQuery: String) {
  viewer {
    notificationThreads(first: \$first, after: \$endCursor, query: \$miscQuery) {
      totalCount
      pageInfo {
        hasNextPage endCursor
      }
      nodes {
        id title subject {
          __typename ... on PullRequest {
            state resourcePath
          }
          ... on Issue {
            state resourcePath
          }
          ... on Discussion {
            isAnswered resourcePath
          }
        }
      }
    }
  }
}
"

MARK_IDS_AS_DONE_QUERY="
  mutation MarkNotificationsAsDone(\$ids: [ID!]!) {
    markNotificationsAsDone(input: {ids: \$ids}) {
      success
    }
  }
"

BASE_QUERY="is:unread is:read"
STATES='"CLOSED","MERGED"'
BASE_LIMIT=50
VERBOSE=0

help() {
  echo "gh clean-notifications"
  echo "Cleans up merged and closed items from notifications in github."
  echo "Syntax: gh clean-notifications [-h|-q|-l]"
  echo ""
  echo "Options:"
  echo " -h -> Help"
  echo " -q -> Query to pass onto getting notifications"
  echo "       Same as available here: https://github.com/notifications"
  echo "       Default: is:unread is:read"
  echo " -l -> Limit on pagination. Default 50."
  echo " -s -> Set the states to mark down as. Default is closed, and merged"
  echo " -v -> Verbose messaging."
}

process_notifications() {
  data=$(gh api graphql \
    -F first="${BASE_LIMIT}" -F miscQuery="${BASE_QUERY}" \
    -f query="${NOTIFICATION_QUERY}" \
    --paginate \
    -q ".data.viewer.notificationThreads.nodes[] | select(.subject.state == (${STATES})) | {\"id\":.id,\"title\":.title,\"path\":.subject.resourcePath}"
  )

  readarray -t my_array < <(echo "${data}" | jq -s -c '.[]')

  # If there are IDs, mark them as done.
  if [ ${#my_array[@]} -gt 0 ]; then
    IDS=()
    for item in "${my_array[@]}"; do
      echo "Marking as Done: $(echo "${item}" | jq -r .title)"
      echo "                 https://github.com$(echo "${item}" | jq -r .path)"
      IDS+=(-f "ids[]=$(echo "${item}" | jq -r .id)")
    done

    gh api graphql --silent "${IDS[@]}" -f query="${MARK_IDS_AS_DONE_QUERY}"

  else
    echo "No tasks to mark as done!"
  fi
}


while getopts :hq:l:s:v flag
do
  case "${flag}" in
    h)  # Display help
      help
      exit;;

    q)  # Update default query
      BASE_QUERY=${OPTARG};;

    l)  # Update base limit
      value=${OPTARG}
      re='^[0-9]+$'
      if ! [[ $value =~ $re ]] ; then
        echo "-l wasn't set to a number: ${value}" >&2;
        exit 1;
      fi
      BASE_LIMIT=${value};;

    v)  # Do verbose messages
      VERBOSE=1;;

    s)  # Process states into a string for jq
      value=${OPTARG^^}
      oldIFS=$IFS
      IFS=','
      STATES=""
      values=( "${value}" )
      IFS=$oldIFS

      for item in "${values[@]}"; do
        if [ -z "${STATES}" ]; then
          STATES="\"${item}\""
        else
          STATES="${STATES},\"${item}\""
        fi
      done;;

    \?)
      echo "Error: Invalid option was specified." >&2;
      echo "" >&2
      help
      exit 2;;
  esac
done

if [ ${VERBOSE} -gt 0 ]; then
  echo "Input arguments are:"
  echo "Query: ${BASE_QUERY}"
  echo "Limit: ${BASE_LIMIT}"
  echo "States: ${STATES}"
fi

process_notifications
